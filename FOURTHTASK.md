## 4. Refactoring. Preparation for deployment & delivery

### 4.1. Making changes to the system. Refactoring

На цьому етапі я не просто дописував функціонал, а трохи «причесав» проєкт, щоб його було легше підтримувати, тестувати і деплоїти.

**1) Перехід на builder для `ChatMessage`**

Спочатку об’єкт повідомлення створювався через звичайний конструктор з кількома аргументами.  
Після рефакторингу я використовую підхід `builder` (Lombok).

- Де змінював у коді:
  - клас `ChatMessage` — `org.example.mtspd.model.ChatMessage` (додав `@Builder`);
  - місця створення повідомлень — у `org.example.mtspd.service.ChatService` та в тестах
    `ChatServiceTest`, `ChatMessageRepositoryIntegrationTest` перевів на `ChatMessage.builder()...build()`.
- Навіщо:
  - код створення став більш читабельним;
  - простіше додавати нові поля в модель, не ламаючи конструктори;
  - менше шансів переплутати порядок параметрів.

---

**2) Винесення валідації в окремі фільтри (SRP + OCP)**

Спочатку вся валідація повідомлень була «зашита» прямо в `ChatService`.  
Після рефакторингу я виніс перевірки в окремі компоненти-фільтри, які реалізують спільний інтерфейс.

- Де змінював у коді:
  - створив інтерфейс `MessageFilter` в пакеті `org.example.mtspd.filter`;
  - реалізації типу `LengthMessageFilter`, `BadWordsFilter` — там само;
  - у `org.example.mtspd.service.ChatService` додав залежність `List<MessageFilter>` і послідовний виклик усіх фільтрів перед збереженням повідомлення в БД.
- Навіщо:
  - сервіс тепер відповідає тільки за процес (SRP), а не за деталі кожної перевірки;
  - нову перевірку можна додати у вигляді нового фільтра, не змінюючи сам сервіс (OCP);
  - фільтри можна легко тестувати окремо або вимикати/міняти місцями.

---

**3) Розділення шарів на пакети (структурний рефакторинг)**

Спочатку класи були розкидані не дуже логічно. Я розклав їх по пакетах за шарами.

- Де змінював у коді:
  - моделі БД (`ChatMessage`, за потреби інші) — в `org.example.mtspd.model`;
  - DTO (`ChatMessageDto`, `SendMessageRequest`, `ChatInboundMessage`) — в `org.example.mtspd.dto`;
  - контролери (`ChatController`, WebSocket-контролер) — в `org.example.mtspd.controller`;
  - сервіси (`ChatService`) — в `org.example.mtspd.service`;
  - репозиторії (`ChatMessageRepository`) — в `org.example.mtspd.repo`;
  - фільтри (`MessageFilter` + реалізації) — в `org.example.mtspd.filter`.
- Навіщо:
  - стало зрозуміло, де що лежить;
  - легше орієнтуватися в проєкті і швидко знаходити потрібний клас;
  - зручніше пояснювати архітектуру на захисті.

---

**4) Очищення `pom.xml` від зайвих залежностей**

На початку у `pom.xml` було багато зайвих залежностей із руками прописаними версіями (`spring-websocket`, `spring-messaging`, `jackson-*` і т.д.). Це загрожувало конфліктами версій і ускладнювало підтримку.

- Де змінював у коді:
  - файл `pom.xml` у корені проєкту.
- Що зробив:
  - залишив тільки потрібні стартери:
    - `spring-boot-starter-web`,
    - `spring-boot-starter-websocket`,
    - `spring-boot-starter-data-mongodb`,
    - `spring-boot-starter-test`,
    - `lombok`;
  - забрав ручні версії для Jackson, `spring-websocket`, `spring-messaging`;
  - версії бібліотек тепер контролюються через `spring-boot-starter-parent`.
- Навіщо:
  - `pom.xml` став коротший і зрозуміліший;
  - менше шансів отримати проблеми з несумісними версіями.

---

**5) Підготовка до Docker-деплойменту (окремий профіль `docker`)**

Щоб зручно деплоїти застосунок у Docker, я розвів конфігурацію для локального запуску і для контейнера.

- Де змінював у коді:
  - `src/main/resources/application.properties` — залишив для локального запуску (IDE + Mongo на `localhost`);
  - додав `src/main/resources/application-docker.properties` — спецконфіг для запуску в контейнері;
  - додав `Dockerfile` у корінь проєкту;
  - оновив `docker-compose.yml` у корені (додав сервіс `app`, який будується з `Dockerfile`).
- Суть:
  - у `application.properties`:
    spring.data.mongodb.uri=mongodb://localhost:27017/tourist-chat
  - у `application-docker.properties`:
    spring.data.mongodb.uri=mongodb://mongo:27017/tourist-chat
    (`mongo` — це ім’я сервісу в `docker-compose`);
  - у `Dockerfile` та `docker-compose.yml` через змінну `SPRING_PROFILES_ACTIVE=docker` вмикається саме докерний профіль.
- Навіщо:
  - не потрібно руками міняти URI при переході з локального запуску на Docker і назад;
  - одна і та сама збірка (jar) може працювати в різних середовищах просто через інший профіль.

---

### 4.2. Functional testing (3+ tests). Description

Тут я описую саме функціональне тестування — як поводиться система з точки зору користувача, а не JUnit-код.

**Тест 1. Підключення до кімнати та завантаження історії**

- Кроки:
  1. Запустити MongoDB (або через `docker-compose up -d`, або окремо).
  2. Запустити Spring Boot-застосунок.
  3. Відкрити в браузері `http://localhost:8080/`.
  4. Ввести нікнейм, обрати кімнату (наприклад, `Europe`) і натиснути кнопку `Join`.
- Очікуваний результат:
  - кнопка `Join` стає неактивною, `Leave` навпаки стає доступною;
  - у вікні чату з’являються останні повідомлення цієї кімнати (якщо вони були в базі);
  - поле введення повідомлення стає активним, можна щось написати.

---

**Тест 2. Обмін повідомленнями між двома користувачами в реальному часі**

- Кроки:
  1. Відкрити дві вкладки браузера з адресою `http://localhost:8080/` (або два різних браузери).
  2. У першій вкладці ввести нікнейм, обрати кімнату `Europe`, натиснути `Join`.
  3. У другій вкладці ввести інший нік, теж обрати `Europe`, натиснути `Join`.
  4. У першій вкладці надіслати повідомлення, наприклад: `Hello from user 1`.
  5. У другій вкладці надіслати `Hello from user 2`.
- Очікуваний результат:
  - в обох вкладках видно обидва повідомлення;
  - у кожного повідомлення правильний автор (відповідає введеному ніку);
  - час показується адекватно (поточний час відправки);
  - сторінка не перезавантажується, всі оновлення приходять «на льоту».

---

**Тест 3. Перевірка валідації порожнього повідомлення**

- Кроки:
  1. Підключитися до будь-якої кімнати (наприклад, `World`).
  2. У поле введення нічого не вводити або набрати тільки пробіли.
  3. Натиснути `Send` або Enter.
- Очікуваний результат:
  - нове повідомлення не з’являється в списку;
  - застосунок не падає, на UI немає помилок;
  - на бекенді спрацьовує перевірка (фільтр), і до MongoDB нічого не зберігається.

---

**Тест 4 (додатковий). Перевірка параметра `limit` для історії**

- Кроки:
  1. Надіслати в одну й ту саму кімнату більше 20 різних повідомлень.
  2. Відкрити нову вкладку, підключитися до цієї кімнати.
- Очікуваний результат:
  - в історії видно тільки останні N повідомлень (за замовчуванням `limit=20`);
  - найстаріші повідомлення не потрапляють у відповідь.

---

### 4.3. Creating the installer/package for deployment (unpacking)

Як «інсталер» я використовую простий варіант: зібраний jar + конфіги + docker-compose, упаковані в архів.

**Крок 1. Збірка застосунку**

У корені проєкту:

mvn clean package

У результаті з’являється jar, наприклад:

target/MTSPD-0.0.1-SNAPSHOT.jar

---

**Крок 2. Формування пакета (умовний `tourist-chat.zip`)**

У підготовлену папку (наприклад, `dist/`) я кладу:

- `MTSPD-0.0.1-SNAPSHOT.jar`;
- `application.properties` (локальна конфігурація) та/або `application-docker.properties` (для Docker);
- `docker-compose.yml` (де вже описані сервіси `mongo` та `app`);
- простий текстовий файл `RUN.txt` із короткою інструкцією:

У `RUN.txt` приблизно так:

1. Встановити Java 17 та Docker.
2. Запустити MongoDB та застосунок:
   docker-compose up --build
3. Відкрити браузер: http://localhost:8080/

Цю папку архівую в `tourist-chat.zip` — це і є мій «інсталер».

---

**Крок 3. Розгортання на іншій машині**

На іншій машині користувач:

1. Розпаковує `tourist-chat.zip` у будь-яку папку.
2. В цій папці запускає:

   docker-compose up --build

3. Після того, як контейнер з апкою піднявся, відкриває `http://localhost:8080/` і користується чатом.

---

### 4.4. Measurement of resource capacity. System requirements

Проєкт невеликий, тому вимоги до ресурсів досить скромні. Тут я орієнтувався на локальний запуск для кількох користувачів.

**Мінімальні системні вимоги:**

- ОС:
  - Windows 10 / Linux / macOS (будь-яка сучасна).
- ПЗ:
  - Java 17 (JDK або JRE);
  - Docker (для Mongo і/або для самого застосунку).
- Процесор:
  - 1 логічне ядро.
- Оперативна пам’ять:
  - ~512 МБ для Java-застосунку;
  - ~256 МБ для MongoDB (для тестового використання).
- Диск:
  - від 200–300 МБ (jar, Docker-образ, невелика база з повідомленнями).

**Оптимальні системні вимоги:**

- Процесор:
  - 2 логічних ядра.
- Оперативна пам’ять:
  - 1–2 ГБ (разом із ОС, MongoDB і браузером).
- Диск:
  - від 1 ГБ для зберігання історії чату на довший період.

На практиці застосунок нормально працює на звичайному ноутбуці.

---

### 4.5. API documentation, user guide for installation and use. Verification

#### 4.5.1. API documentation (скорочено)

**REST API**

1. GET /api/chat/rooms/{room}/history?limit=N
   - Призначення: повернути останні N повідомлень у кімнаті room.
   - Параметри:
     - room (path) — назва кімнати (наприклад, Europe);
     - limit (query, optional) — кількість повідомлень, за замовчуванням 20.
   - Відповідь: JSON-масив об’єктів:

     {
       "id": "string",
       "room": "Europe",
       "author": "Alice",
       "text": "Hello from Rome",
       "sentAt": "2024-10-10T10:00:00Z"
     }

(Якщо в проєкті залишився POST /api/chat/rooms/{room}/messages, можна коротко описати аналогічно.)

---

**WebSocket / STOMP API**

- Endpoint для підключення:
  ws://{host}:8080/ws-chat (на практиці через SockJS — /ws-chat).

- Клієнт надсилає повідомлення на:
  /app/chat/{room}
  туди відправляється JSON:

  {
    "nickname": "Alice",
    "text": "Hello from Rome"
  }

- Клієнт підписується на канал кімнати:
  /topic/rooms/{room}
  і отримує об’єкти виду:

  {
    "id": "string",
    "room": "Europe",
    "author": "Alice",
    "text": "Hello from Rome",
    "sentAt": "2024-10-10T10:00:00Z"
  }

---

#### 4.5.2. User guide: installation & use

**Встановлення (локально через Docker)**

1. Встановити:
   - Java 17;
   - Docker і Docker Compose.
2. Скопіювати/розпакувати папку проєкту (або tourist-chat.zip).
3. У корені папки виконати:

   mvn clean package
   docker-compose up --build

   або, якщо jar вже зібраний, просто:

   docker-compose up --build

Після цього:
- MongoDB піднімається як сервіс mongo;
- застосунок стартує як сервіс app на порту 8080.

**Запуск без Docker (через IDE / командний рядок)**

1. Запустити MongoDB локально (окремим контейнером або встановленим сервером) на:

   localhost:27017

   з базою tourist-chat.
2. Запустити застосунок:

   mvn spring-boot:run

   або:

   java -jar target/MTSPD-0.0.1-SNAPSHOT.jar

---

**Використання веб-інтерфейсу**

1. Відкрити браузер:
   http://localhost:8080/
2. В полі Nickname ввести будь-який нік (можна англійською).
3. Вибрати кімнату зі списку (World, Europe, Asia, CityTips).
4. Натиснути кнопку Join.
5. У нижньому полі ввести текст повідомлення і натиснути Send (або Enter).
6. Щоб вийти з кімнати, натиснути кнопку Leave.

---

#### 4.5.3. Verification of documentation

Щоб перевірити, що документація працює, я пройшов повний шлях «як новий користувач»:

1. Взяв чисту папку, розпакував туди архів із застосунком.
2. Послідовно виконав усі кроки з розділу про встановлення:
   - mvn clean package;
   - docker-compose up --build;
   - відкрив http://localhost:8080/ у браузері.
3. Перевірив, що:
   - інтерфейс чату відкривається;
   - можна зайти під нікнеймом, обрати кімнату, написати повідомлення;
   - історія повідомлень підтягується, нові повідомлення з’являються без перезавантаження сторінки.

Після цього я трохи підправив формулювання в гайді (прибрав зайве і залишив тільки конкретні кроки). У поточному вигляді інструкцію можна дати людині, яка не бачила код, і вона зможе розгорнути й запустити чат.
