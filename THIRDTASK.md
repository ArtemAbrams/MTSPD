# Tourist Chat — опис проєкту

Це веб-чат для туристів, де люди можуть обмінюватися порадами, враженнями та питаннями про різні країни й міста в режимі реального часу.

Головна ідея — показати повний цикл розробки веб-застосунку: від вимог і проєктування до бекенду, фронтенду, тестів.

---

## Ідея та призначення

Уявна ситуація: турист готується до поїздки або вже знаходиться в іншій країні й хоче швидко запитати щось у людей, які там були або живуть. Замість того, щоб шукати форуми чи довгі гілки в соцмережах, є простий чат з кімнатами за регіонами.

Основні сценарії використання:
- зайти в чат без реєстрації, вказавши лише нік;
- обрати потрібну кімнату;
- подивитися останні повідомлення;
- написати своє повідомлення й одразу побачити його в загальному чаті;
- спостерігати нові повідомлення інших користувачів у реальному часі.

---

## Основний функціонал

1. **Вибір нікнейму та кімнати**
    - користувач вводить довільний нік (якщо не ввів — може генеруватися простий guest-нік);
    - обирає кімнату чату зі списку (глобальний чат або окремі регіони).

2. **Завантаження історії**
    - при вході в кімнату завантажуються останні повідомлення;
    - користувач одразу бачить контекст того, що вже обговорювали до нього.

3. **Обмін повідомленнями в реальному часі**
    - нові повідомлення миттєво з’являються в усіх користувачів, підключених до тієї ж кімнати;
    - оновлення відбувається без перезавантаження сторінки.

4. **Валідація повідомлень**
    - перевірка, що повідомлення не порожнє;
    - обмеження максимальної довжини повідомлення;
    - логіку додаткових перевірок (наприклад, фільтрація небажаних слів) винесено в окремі фільтри, які можна підключати або вимикати.

5. **Зберігання історії в базі**
    - кожне повідомлення зберігається в базі даних з прив’язкою до кімнати, автора та часу;
    - при перезапуску застосунку історія не втрачається, її можна знову запросити.

---

## Загальна структура застосунку

У застосунку можна умовно виділити два основних рівні: бекенд і фронтенд.

### Бекенд

На стороні сервера логіка поділена на декілька шарів:

- **Контролер**  
  Приймає HTTP-запити (для завантаження історії) і WebSocket-повідомлення (для реального часу).  
  Через REST-контролер фронтенд отримує останні N повідомлень кімнати.  
  Через WebSocket-контролер сервер приймає нові повідомлення і розсилає їх усім підписаним клієнтам.

- **Сервіс**  
  Відповідає за бізнес-логіку:
    - валідацію вхідних даних;
    - запуск ланцюжка фільтрів повідомлення;
    - збереження повідомлення в базу;
    - підготовку історії (сортування за часом, перетворення в DTO для фронтенду).

- **Репозиторій**  
  Інкапсулює роботу з базою даних.  
  Дає методи для:
    - збереження нового повідомлення;
    - вибірки останніх повідомлень певної кімнати з сортуванням за часом.

Таким чином, контролер не знає деталей збереження, сервіс не прив’язаний до конкретної реалізації бази, а репозиторій не займається валідацією й форматуванням відповіді.

### Фронтенд

Фронтенд — це одна HTML-сторінка, яку віддає Spring Boot. Вона складається з:

- поля для введення нікнейму;
- списку для вибору кімнати;
- кнопок підключення / відключення від чату;
- області для виведення повідомлень;
- поля введення нового повідомлення та кнопки «Send».

JavaScript-код на сторінці:

- підключається до бекенду по WebSocket (через STOMP);
- підписується на канал кімнати і слухає нові повідомлення;
- при підключенні один раз запитує історію через HTTP;
- при надсиланні повідомлення відправляє його на сервер і відразу відображає те, що приходить у відповідь.

---

## Дотримання принципів SOLID

У проєкті свідомо дотримано принаймні трьох принципів SOLID:

1. **SRP (Single Responsibility Principle)**  
   Кожен клас має свою чітку відповідальність:
    - контролер працює тільки з HTTP/WebSocket-рівнем (приймає запит, віддає відповідь);
    - сервіс відповідає за бізнес-логіку (валідація, фільтри, збереження, підготовка DTO);
    - репозиторій ізолює роботу з базою даних (запис і читання з MongoDB).  
      Завдяки цьому зміни в одному шарі мінімально впливають на інші.

2. **OCP (Open/Closed Principle)**  
   Валідацію повідомлень реалізовано через окремі фільтри. Сервіс не «зашитий» під конкретні перевірки: він просто викликає список фільтрів. Якщо потрібно додати нове правило (наприклад, іншу перевірку довжини або розширену цензуру), достатньо додати новий фільтр і підключити його, не змінюючи основний код сервісу.

3. **DIP (Dependency Inversion Principle)**  
   Високорівневі класи залежать від абстракцій, а не від конкретних реалізацій:
    - сервіс працює з інтерфейсом репозиторію, а не з конкретним класом з’єднання з базою;
    - набір фільтрів передається у вигляді інтерфейсів, тому можна легко замінити чи додати реалізації.  
      Це спрощує тестування і робить застосунок гнучкішим до змін.

---

## Тести

У проєкті є кілька типів тестів.

- **Модульні тести сервісу**  
  Перевіряють:
    - що при коректних даних повідомлення зберігається і повертається у правильному форматі;
    - що порожній текст або надто довге повідомлення викликають помилку;
    - що історія повідомлень віддається у правильному порядку (від старих до нових).

- **Інтеграційні тести репозиторію**  
  Запускають тестовий контекст із реальною MongoDB (окремою тестовою базою) і перевіряють:
    - що дані коректно зберігаються;
    - що запит на останні повідомлення кімнати повертає очікуваний результат.

- **Інтеграційні тести контролера**  
  Перевіряють повний шлях:
    - створення нового повідомлення;
    - запис у базу;
    - отримання цього ж повідомлення через HTTP-ендпоінт історії.

Після завершення інтеграційних тестів записи, створені у тестовій базі, видаляються, щоб кожен запуск тестів починався з «чистого» стану.

---
